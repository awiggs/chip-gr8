
// Generated by Page Builder
import Page from './Page';
import _    from 'lodash';

export default {

    $pages() {
        return Object.values(this).filter(page => page instanceof Page);
    },

    $blogs() {
        return this.$pages().filter(page => page.blog).sort(Page.compareDates);
    },

    $search(searchText) {
        const regex   = new RegExp(_.escapeRegExp(_.escape(searchText)), 'i');
        const results = [];
        for (const page of this.$pages()) {
            if (page.$searchRegex(regex)) {
                results.push(page);
            }
        }
        return results;
    },

    'about': new Page({
        name: 'about',
        content: "# Meet Our Team\n\nWe are a group of Software, and Electrical, Engineering students from the University of Victoria. With passions for programming, artificial intelligence, and gaming, we came together to deliver an artificial intelligence tool that will enable future generations to share in our love for technology and creating something new.\n\nEric is a fourth-year Software Engineering student graduating in August 2019. He is a Canadian through-and-through having already lived and worked in 5 Canadian provinces. His love for creative projects and problem-solving led him to his studies at UVic. Eric brings his passion for code and design to all his projects both in and out of school.\n\nTorrey plans to graduate UVic with a Bachelor of Software Engineering degree in 2019. Come October, she will be starting her career as a Firmware Developer at Reliable Controls in the beautiful city of Victoria. She hopes to one day follow her dream of working for NASA.\n\nJon is a fourth year Software Engineering student aiming to graduate in 2020. He hails from Prince George BC, and moved to Victoria to study general engineering at UVic in 2014. Jon spends his time writing Dungeons and Dragons campaigns and working on his personal coding projects. After graduation he hopes to remain in Victoria.\n\n// Text for James here\n\nAndrew is a fourth year Software Engineering student who plans on graduating in April 2020. He started his University career in the Faculty of Science, but transitioned into Software Engineering after discovering a fondness for programming. After graduation he plans on moving to Vancouver to pursue a career as a developer.\n\n// Text for Forrest here\n\n# Acknowledgements\nSeveral people made this project possible and we would like to acknowledge their involvement in Chip-Gr8's development journey, and extend to them our deepest thanks.\n\n## Faculty Supervisor\nWe chose Rich Little as our faculty supervisor for his background in algorithms and based on our positive experiences with him in CSC 225 and 226 courses. He was responsible for supervising the project during its development cycle and for marking all of the milestones. Thank you to Rich Little for the help he provided along the way.\n\n## Supporters\n\n#### Dr. Xiaodai Dong\nThank you to Dr. Xiaodai Dong for being the primary instructor this semester.\n\n#### Dr. T. Ilamparithi\nThank you to Dr. Ilamparithi for being the course coordinator this semester.\n\n#### Sai Prakash Reddy Konda\nThank you to the TA for their help with the course.\n",
        plainTxt: 'Meet Our Team\nWe are a group of Software, and Electrical, Engineering students from the University of Victoria. With passions for programming, artificial intelligence, and gaming, we came together to deliver an artificial intelligence tool that will enable future generations to share in our love for technology and creating something new.\nEric is a fourth-year Software Engineering student graduating in August 2019. He is a Canadian through-and-through having already lived and worked in 5 Canadian provinces. His love for creative projects and problem-solving led him to his studies at UVic. Eric brings his passion for code and design to all his projects both in and out of school.\nTorrey plans to graduate UVic with a Bachelor of Software Engineering degree in 2019. Come October, she will be starting her career as a Firmware Developer at Reliable Controls in the beautiful city of Victoria. She hopes to one day follow her dream of working for NASA.\nJon is a fourth year Software Engineering student aiming to graduate in 2020. He hails from Prince George BC, and moved to Victoria to study general engineering at UVic in 2014. Jon spends his time writing Dungeons and Dragons campaigns and working on his personal coding projects. After graduation he hopes to remain in Victoria.\n// Text for James here\nAndrew is a fourth year Software Engineering student who plans on graduating in April 2020. He started his University career in the Faculty of Science, but transitioned into Software Engineering after discovering a fondness for programming. After graduation he plans on moving to Vancouver to pursue a career as a developer.\n// Text for Forrest here\nAcknowledgements\nSeveral people made this project possible and we would like to acknowledge their involvement in Chip-Gr8&#39;s development journey, and extend to them our deepest thanks.\nFaculty Supervisor\nWe chose Rich Little as our faculty supervisor for his background in algorithms and based on our positive experiences with him in CSC 225 and 226 courses. He was responsible for supervising the project during its development cycle and for marking all of the milestones. Thank you to Rich Little for the help he provided along the way.\nSupporters\nDr. Xiaodai Dong\nThank you to Dr. Xiaodai Dong for being the primary instructor this semester.\nDr. T. Ilamparithi\nThank you to Dr. Ilamparithi for being the course coordinator this semester.\nSai Prakash Reddy Konda\nThank you to the TA for their help with the course.\n',
        route: '/about',
        layout: '../layouts/About',
        title: 'chip-gr8 | About',
        place: 'about',
    }),
    'api': new Page({
        name: 'api',
        content: "# Introduction\n[Click here]() to download the Chip-Gr8 User Manual, which contains more in-depth descriptions of the Chip-Gr8 project.\n\nThis section details the API of Chip-Gr8. It is broken down into the primary classes, including all fields and methods, as well as other important functions.\n\n\n# Chip8VM (Class)\nRepresents a CHIP-8 virtual machine. Provides interface and controls for display and input. Rather than initializing directly, an instance of this class or its sister class **Chip8VMs** should always be instantiated using **init**.\n\n## Fields\n\n## `.aiInputMask`\nA number that controls what keys are usable by AI agents calling **act** and what keys are usable by a user on their keyboard. For example, an **aiInputMask** of 0x0000 will prevent an AI agent from using any keys, but a user will be able to use all keys.\n\n## `.inputHistory`\nA list of number pairs that represent changes in key presses. The first value in the pair is the key value, the second is the clock value when input changed to that value.\n\n## `.paused`\nA control flag set to True if the display is paused.\n\n## `.pyclock`\nThe pygame clock used to keep track of time between steps when using the CHIP-GR8 display.\n\n## `.record`\nA control flag set to True if **inputHistory** is being recorded.\n\n## `.ROM`\nThe path to the currently loaded game ROM.\n\n## `.sampleRate`\nThe number of steps that are performed when an AI calls **act**.\n\n## `.smooth`\nA control flag for the experimental smooth rendering mode. This mode is slow on most machines.\n\n## `.VM`\nA direct reference to the CHIP-8 c-struct. This provides direct memory access (eg. **VM.RAM[0x200]**) as well as register reference (eg. **VM.PC**). Use these fields with caution as inappropriate usage can result in a segmentation fault. Direct references to **VM** should not be maintained (no aliasing).\n\n## Methods\n\n## `.act(action)`\nAllows an AI agent to perform **action** (action is an input key value) and steps the CHIP-8 emulator forward **sampleRate** clock cycles.\n\n## `.ctx()`\nReturns an instance of the CHIP-8’s VRAM in a numpy compliant format (lazyarray). Pixel values can be addressed directly. (eg. a pixel at position (16, 8) can be retrieved with **ctx()[16, 8]**). This method is safe to call repeatedly.\n\n## `.done()`\nReturns True if the VM is done and has NOT been reset.\n\n## `.doneIf(done)`\nSignals to the VM that it is done.\n\n## `.go()`\nStarts the VM in an until **done()** loop, calling **act(0)** repeatedly. This is ideal for user interaction without an AI agent.\n\n## `.input(keys)`\nSend an input key value to the CHIP-8 emulator. Input keys are masked by **aiInputMask**.\n\n## `.loadROM(nameOrPath, reset=True)`\nLoads a ROM from the provided path or searches for the name in the set of provided ROM files. If **reset** is True then VM will be reset prior to loading the ROM.\n\n## `.loadState(path=None, tag=None)`\nLoad a CHIP-8 emulator state from a **path** or by associated **tag**, restoring a previous state of **VM**.\n\n## `.saveState(path=None, tag=None)`\nSave the current CHIP-8 emulator state to a **path** or **tag**.\n\n## `.reset()`\nReset the VM with the current ROM still loaded.\n\n## `.step()`\nStep the VM forward 1 clock cycle.\n\n# Chip8VMs (Class)\nRepresents a collection of CHIP-8 virtual machines. Provides an interface for interfacing with and filtering several virtual machines at the same time. This class is iterable, and will iterate over all vms that are NOT **done()**.\n\n## Methods\n\n## `.done()`\nReturns True if all vm instances are done.\n\n## `.find(predicate)`\nFind a specific vm using a function **predicate** that takes a vm as an argument and returns True or False. Returns the first vm for which the **predicate** was True. Searches done and not done vms.\n\n## `.inParallel(do)`\nPerforms a function **do** on all not done vms in parallel. The function is expected to take the vm as an argument. When using this method external vm references can become out of date due to pickling across processes. \n\n## `.maxBy(projection)`\nReturns the vm with the maximum value by the given **projection**, a function that takes a vm as its argument and returns a comparable value.\n\n## `.minBy(projection)`\nReturns the vm with the minimum value by the given **projection**, a function that takes a vm as its argument and returns a comparable value.\n\n## `.reset()`\nResets all the vms\n\n# disassemble((Parameters))\nConverts a binary ROM into an assembly source file. Returns the source. Provides option for disassembling with labels and special format.\n\n## Parameters\n\n## `buffer=None`\nThe binary ROM to disassemble as a set of bytes. Optional if **inPath** is provided.\n\n## `inPath=None`\nThe path to a binary ROM to disassemble. Optional if **buffer** is provided.\n\n## `outPath=None`\nIf the path is provided, the source code is written to that file.\n\n## `labels={}`\nA dictionary used to generate labels. If None is passed, labels will not be generated in the source.\n\n## `decargs=True`\nIf True, instruction numerical operands will be output in decimal rather than hexadecimal.\n\n## `prefix=' '`\nThe string used to prefix all instructions.\n\n## `hexdump=False`\nIf True, all instructions will be postfixed with a comment displaying the hexadecimal value of the instruction.\n\n## `labelSep = '\\n '`\nThe string used to separate labels from instructions.\n\n# findROM(rom)\nReturns the path to **rom** if it is one of the included ROMs.\n\n# Game (Class)\nA generic class for game specific data. Game specific instances of this class exist for each included ROM (cave, pong, work).\n\n## Fields\n\n## `.actions`\nA list of valid actions (key values) for the given game.\n\n## `.ROM`\nThe name of the ROM file for this game.\n\n## Methods\n\n## `.observe(vm)`\nReturns a set of game specific observations given a vm.\n\n# hexdump(buffer=None, inPath=None, outPath=None)\nDumps a **buffer** or file at **inPath** as a set of 16bit hexadecimal values on each line (the number of bits that correspond to a CHIP-8 instruction). Writes the data to **outPath** if provided.\n\n# init((Parameters))\n\n## Parameters\n\n## `ROM=None`\nIf provided will load a ROM into the vm instance or instances.\n\n## `frequency=600`\nThe starting **frequency** of the vm instance or instances. Will automatically be set to the closest multiple of 60 less than or equal to the provided **frequency**.\n\n## `loadState=None`\nA path or tag to a vm save state that will be loaded into each vm instance or instances.\n\n## `inputHistory=None`\nIf provided user and AI input will be ignored and the history will be used to reproduce the same events.\n\n## `sampleRate=1`\nThe number of steps that are performed when an AI calls **act**.\n\n## `instances=1`\nThe number of vm instances to create.\n\n## `display=False`\nIf True, the vm will create a Chip-Gr8 display. Cannot be True if instances does not equal 1.\n\n## `smooth=False`\nIf True, enables the experimental smooth rendering mode. This mode is slow on most machines.\n\n## `startPaused=False`\nIf True, the vm instance will start paused.\n\n## `aiInputMask=0xFFFF`\nThe key usable to the AI agent as a bitmask. The keys available to the user are the bitwise inverse of this mask.\n\n## `foreground=(255, 255, 255)`\nThe foreground color of the Chip-Gr8 display as an RGB tuple or hex code.\n\n## `background=(0, 0, 0)`\nThe background color of the Chip-Gr8 display as an RGB tuple or hex code.\n\n## `theme=None`\nThe foreground/background color provided as a tuple.\n\n## `autoScroll=True`\nIf True, this disassembly source will automatically scroll when the Chip-Gr8 display is open and a ROM is running.\n\n# NamedList (Class)\nA list-like structure that allows elements to be accessed by named properties. Behaves like a Python list, can be iterated, indexed, spliced, and measured with **len()**.\n\n## Fields\n\n## `.names`\nA list of keys for the list in order.\n\n## `.values`\nA list of values for the list in order.\n\n## Methods\n\n## `.append(name, value)`\nAppend a **name** and **value** to the list.\n\n## `.nparray()`\nRetrieve the valyes of the list as a numpy ndarray.\n\n## `.tensor()`\nRetrieve the values of the list as a tensorflow tensor.\n\n# Observer (Class)\nRepresents a collection of queries that can be applied to a vm acquiring a set of observations.\n\n## Methods\n\n## `.addQuery(name, query)`\nAdd a query with an associated name to an observer. Accepts either a finalized query or a function that accepts a set of observations **(NamedList)** as the first argument and a vam instance as its second argument. This function argument can be used to create compound queries.\n\n## `.observe(vm)`\nRetrieve a set of observations as a **NamedList** given a **vm** instance.\n\n# Query (Class)\nUsed to find a specific memory address. When using a query to search for a memory address, several predicates can be used to filter the query.\n\n## Fields\n\n## `.done`\nTrue if the query has found 0 or 1 addresses.\n\n## `.success`\nTrue if the query has found 1 address.\n\n## Methods\n\n## `.dec()`\nFilter queried memory addresses by values that have decreased since the last query.\n\n## `.eq(value)`\nFilter queried memory addresses by values that equal **value**.\n\n## `.gt(value)`\nFilter queried memory addresses by values that are greater than **value**.\n\n## `.gte(value)`\nFilter queried memory addresses by values that are greater than or equal to **value**.\n\n## `.inc()`\nFilter queried memory addresses by values that have increased since the last query.\n\n## `.lt(value)`\nFilter queried memory addresses by values that are less than **value**.\n\n## `.lte(value)`\nFilter queried memory addresses by values that are less than or equal to **value**.\n\n## `.observe(vm)`\nIf a query is successful this method returns the value at the vm instance's RAM corresponding to this query.\n\n## `.unknown()`\nRefresh the previous values of all currently queried memory addresses.\n\n# readableInputHistory(inputHistory, names)\nGiven an **inputHistory** and a set of actions, **names**, as a **NamedList**, produces a human readable version of the **inputHistory**.\n",
        plainTxt: 'Introduction\nClick here to download the Chip-Gr8 User Manual, which contains more in-depth descriptions of the Chip-Gr8 project.\nThis section details the API of Chip-Gr8. It is broken down into the primary classes, including all fields and methods, as well as other important functions.\nChip8VM (Class)\nRepresents a CHIP-8 virtual machine. Provides interface and controls for display and input. Rather than initializing directly, an instance of this class or its sister class Chip8VMs should always be instantiated using init.\nFields\n.aiInputMask\nA number that controls what keys are usable by AI agents calling act and what keys are usable by a user on their keyboard. For example, an aiInputMask of 0x0000 will prevent an AI agent from using any keys, but a user will be able to use all keys.\n.inputHistory\nA list of number pairs that represent changes in key presses. The first value in the pair is the key value, the second is the clock value when input changed to that value.\n.paused\nA control flag set to True if the display is paused.\n.pyclock\nThe pygame clock used to keep track of time between steps when using the CHIP-GR8 display.\n.record\nA control flag set to True if inputHistory is being recorded.\n.ROM\nThe path to the currently loaded game ROM.\n.sampleRate\nThe number of steps that are performed when an AI calls act.\n.smooth\nA control flag for the experimental smooth rendering mode. This mode is slow on most machines.\n.VM\nA direct reference to the CHIP-8 c-struct. This provides direct memory access (eg. VM.RAM[0x200]) as well as register reference (eg. VM.PC). Use these fields with caution as inappropriate usage can result in a segmentation fault. Direct references to VM should not be maintained (no aliasing).\nMethods\n.act(action)\nAllows an AI agent to perform action (action is an input key value) and steps the CHIP-8 emulator forward sampleRate clock cycles.\n.ctx()\nReturns an instance of the CHIP-8’s VRAM in a numpy compliant format (lazyarray). Pixel values can be addressed directly. (eg. a pixel at position (16, 8) can be retrieved with ctx()[16, 8]). This method is safe to call repeatedly.\n.done()\nReturns True if the VM is done and has NOT been reset.\n.doneIf(done)\nSignals to the VM that it is done.\n.go()\nStarts the VM in an until done() loop, calling act(0) repeatedly. This is ideal for user interaction without an AI agent.\n.input(keys)\nSend an input key value to the CHIP-8 emulator. Input keys are masked by aiInputMask.\n.loadROM(nameOrPath, reset=True)\nLoads a ROM from the provided path or searches for the name in the set of provided ROM files. If reset is True then VM will be reset prior to loading the ROM.\n.loadState(path=None, tag=None)\nLoad a CHIP-8 emulator state from a path or by associated tag, restoring a previous state of VM.\n.saveState(path=None, tag=None)\nSave the current CHIP-8 emulator state to a path or tag.\n.reset()\nReset the VM with the current ROM still loaded.\n.step()\nStep the VM forward 1 clock cycle.\nChip8VMs (Class)\nRepresents a collection of CHIP-8 virtual machines. Provides an interface for interfacing with and filtering several virtual machines at the same time. This class is iterable, and will iterate over all vms that are NOT done().\nMethods\n.done()\nReturns True if all vm instances are done.\n.find(predicate)\nFind a specific vm using a function predicate that takes a vm as an argument and returns True or False. Returns the first vm for which the predicate was True. Searches done and not done vms.\n.inParallel(do)\nPerforms a function do on all not done vms in parallel. The function is expected to take the vm as an argument. When using this method external vm references can become out of date due to pickling across processes. \n.maxBy(projection)\nReturns the vm with the maximum value by the given projection, a function that takes a vm as its argument and returns a comparable value.\n.minBy(projection)\nReturns the vm with the minimum value by the given projection, a function that takes a vm as its argument and returns a comparable value.\n.reset()\nResets all the vms\ndisassemble((Parameters))\nConverts a binary ROM into an assembly source file. Returns the source. Provides option for disassembling with labels and special format.\nParameters\nbuffer=None\nThe binary ROM to disassemble as a set of bytes. Optional if inPath is provided.\ninPath=None\nThe path to a binary ROM to disassemble. Optional if buffer is provided.\noutPath=None\nIf the path is provided, the source code is written to that file.\nlabels={}\nA dictionary used to generate labels. If None is passed, labels will not be generated in the source.\ndecargs=True\nIf True, instruction numerical operands will be output in decimal rather than hexadecimal.\nprefix=&#39; &#39;\nThe string used to prefix all instructions.\nhexdump=False\nIf True, all instructions will be postfixed with a comment displaying the hexadecimal value of the instruction.\nlabelSep = &#39;\\n &#39;\nThe string used to separate labels from instructions.\nfindROM(rom)\nReturns the path to rom if it is one of the included ROMs.\nGame (Class)\nA generic class for game specific data. Game specific instances of this class exist for each included ROM (cave, pong, work).\nFields\n.actions\nA list of valid actions (key values) for the given game.\n.ROM\nThe name of the ROM file for this game.\nMethods\n.observe(vm)\nReturns a set of game specific observations given a vm.\nhexdump(buffer=None, inPath=None, outPath=None)\nDumps a buffer or file at inPath as a set of 16bit hexadecimal values on each line (the number of bits that correspond to a CHIP-8 instruction). Writes the data to outPath if provided.\ninit((Parameters))\nParameters\nROM=None\nIf provided will load a ROM into the vm instance or instances.\nfrequency=600\nThe starting frequency of the vm instance or instances. Will automatically be set to the closest multiple of 60 less than or equal to the provided frequency.\nloadState=None\nA path or tag to a vm save state that will be loaded into each vm instance or instances.\ninputHistory=None\nIf provided user and AI input will be ignored and the history will be used to reproduce the same events.\nsampleRate=1\nThe number of steps that are performed when an AI calls act.\ninstances=1\nThe number of vm instances to create.\ndisplay=False\nIf True, the vm will create a Chip-Gr8 display. Cannot be True if instances does not equal 1.\nsmooth=False\nIf True, enables the experimental smooth rendering mode. This mode is slow on most machines.\nstartPaused=False\nIf True, the vm instance will start paused.\naiInputMask=0xFFFF\nThe key usable to the AI agent as a bitmask. The keys available to the user are the bitwise inverse of this mask.\nforeground=(255, 255, 255)\nThe foreground color of the Chip-Gr8 display as an RGB tuple or hex code.\nbackground=(0, 0, 0)\nThe background color of the Chip-Gr8 display as an RGB tuple or hex code.\ntheme=None\nThe foreground/background color provided as a tuple.\nautoScroll=True\nIf True, this disassembly source will automatically scroll when the Chip-Gr8 display is open and a ROM is running.\nNamedList (Class)\nA list-like structure that allows elements to be accessed by named properties. Behaves like a Python list, can be iterated, indexed, spliced, and measured with len().\nFields\n.names\nA list of keys for the list in order.\n.values\nA list of values for the list in order.\nMethods\n.append(name, value)\nAppend a name and value to the list.\n.nparray()\nRetrieve the valyes of the list as a numpy ndarray.\n.tensor()\nRetrieve the values of the list as a tensorflow tensor.\nObserver (Class)\nRepresents a collection of queries that can be applied to a vm acquiring a set of observations.\nMethods\n.addQuery(name, query)\nAdd a query with an associated name to an observer. Accepts either a finalized query or a function that accepts a set of observations (NamedList) as the first argument and a vam instance as its second argument. This function argument can be used to create compound queries.\n.observe(vm)\nRetrieve a set of observations as a NamedList given a vm instance.\nQuery (Class)\nUsed to find a specific memory address. When using a query to search for a memory address, several predicates can be used to filter the query.\nFields\n.done\nTrue if the query has found 0 or 1 addresses.\n.success\nTrue if the query has found 1 address.\nMethods\n.dec()\nFilter queried memory addresses by values that have decreased since the last query.\n.eq(value)\nFilter queried memory addresses by values that equal value.\n.gt(value)\nFilter queried memory addresses by values that are greater than value.\n.gte(value)\nFilter queried memory addresses by values that are greater than or equal to value.\n.inc()\nFilter queried memory addresses by values that have increased since the last query.\n.lt(value)\nFilter queried memory addresses by values that are less than value.\n.lte(value)\nFilter queried memory addresses by values that are less than or equal to value.\n.observe(vm)\nIf a query is successful this method returns the value at the vm instance&#39;s RAM corresponding to this query.\n.unknown()\nRefresh the previous values of all currently queried memory addresses.\nreadableInputHistory(inputHistory, names)\nGiven an inputHistory and a set of actions, names, as a NamedList, produces a human readable version of the inputHistory.\n',
        route: '/api',
        layout: '../layouts/API',
        title: 'chip-gr8 | API',
        place: 'api',
    }),
    'index': new Page({
        name: 'index',
        content: 'Welcome to Chip-Gr8! This project was the capstone project of six engineering students at the University of Victoria. \nBy combining our passions for gaming and artificial intelligence, we created a CHIP-8 emulator that doubles as a tool for learning how to develop Python AI programs. The aim of this project was to give new generations of programmers a stepping stone application into the world of AI.\n',
        plainTxt: 'Welcome to Chip-Gr8! This project was the capstone project of six engineering students at the University of Victoria. \nBy combining our passions for gaming and artificial intelligence, we created a CHIP-8 emulator that doubles as a tool for learning how to develop Python AI programs. The aim of this project was to give new generations of programmers a stepping stone application into the world of AI.\n',
        route: '/index',
        layout: '../layouts/Docs',
        title: 'chip-gr8',
        subtitle: 'Chip 8 Emulation for AI',
        place: 'home',
    }),
    'project': new Page({
        name: 'project',
        content: "# The Project\nThe aim of this project was to design a high performance emulation engine with a Python API for integration with modern machine learning and AI libraries. Inspiration for the Chip-Gr8 project came from similar emulation + AI combinations of the [NES](https://www.youtube.com/watch?v=qv6UVOQ0F44) and [Atari](https://arxiv.org/pdf/1312.5602v1.pdf) systems.\n\n## What is Chip-Gr8?\nAt its core, Chip-Gr8 is an emulator of the CHIP-8 system. Developed in the 1970's by [Joseph Weisbecker](https://en.wikipedia.org/wiki/Joseph_Weisbecker#Small_systems), CHIP-8 was meant to be a simple system that programmers could use for beginner video game development. Many simple games, including Pong, Space Invaders, and Breakout, were programmed for the CHIP-8 throughout the 70s and 80s.\n\nThe key feature of Chip-Gr8 is the artificial intelligence (AI) API that is integrated into the emulator. This is meant to give developers an introductory experience into video game AI development, as well as modern maching learning techniques and useful AI libraries.\n\n## Why Chip-Gr8?\nAs a team, we wanted a project idea that would both test our skills and that other developers would want to use. Furthermore, since none of us were particularly adept in the field of writing AI agents, we wanted to create a tool that we would have found useful had we been searching for a way to get into AI programming. With Chip-Gr8, the idea is that by providing a simplified Python API into the core of a CHIP-8 emulator, a basic programmer can pick up our tool and create their first Space Invaders, or other supported video game, AI! \n\nWe hoped that by developing not just a marketable product, but an educational tool, that we could excite people into learning the basics of the world of artificial intelligence programming.\n\n## Technologies Used\nThe Chip-Gr8 project was written in C and Python. C was used for the core CHIP-8 emulator opreations and memory management. Python was integrated closely with C using a library called [CTypes](https://docs.python.org/3/library/ctypes.html). Python was used to handle the primary virtual machine structure, load/unload ROMs, as well as any I/O and visual display. Additional libraries used in Python were:\n\n- [NumPy](https://numpy.org/)\n- [PyGame](https://www.pygame.org/news)\n- [Lazyarray](https://lazyarray.readthedocs.io/en/latest/)\n\nFor more detailed information regarding the implementation of Chip-Gr8, including a user manual, check out the [API page](/api)!\n\n# Project Timeline",
        plainTxt: 'The Project\nThe aim of this project was to design a high performance emulation engine with a Python API for integration with modern machine learning and AI libraries. Inspiration for the Chip-Gr8 project came from similar emulation + AI combinations of the NES and Atari systems.\nWhat is Chip-Gr8?\nAt its core, Chip-Gr8 is an emulator of the CHIP-8 system. Developed in the 1970&#39;s by Joseph Weisbecker, CHIP-8 was meant to be a simple system that programmers could use for beginner video game development. Many simple games, including Pong, Space Invaders, and Breakout, were programmed for the CHIP-8 throughout the 70s and 80s.\nThe key feature of Chip-Gr8 is the artificial intelligence (AI) API that is integrated into the emulator. This is meant to give developers an introductory experience into video game AI development, as well as modern maching learning techniques and useful AI libraries.\nWhy Chip-Gr8?\nAs a team, we wanted a project idea that would both test our skills and that other developers would want to use. Furthermore, since none of us were particularly adept in the field of writing AI agents, we wanted to create a tool that we would have found useful had we been searching for a way to get into AI programming. With Chip-Gr8, the idea is that by providing a simplified Python API into the core of a CHIP-8 emulator, a basic programmer can pick up our tool and create their first Space Invaders, or other supported video game, AI! \nWe hoped that by developing not just a marketable product, but an educational tool, that we could excite people into learning the basics of the world of artificial intelligence programming.\nTechnologies Used\nThe Chip-Gr8 project was written in C and Python. C was used for the core CHIP-8 emulator opreations and memory management. Python was integrated closely with C using a library called CTypes. Python was used to handle the primary virtual machine structure, load/unload ROMs, as well as any I/O and visual display. Additional libraries used in Python were:\nNumPy\nPyGame\nLazyarray\n\nFor more detailed information regarding the implementation of Chip-Gr8, including a user manual, check out the API page!\nProject Timeline\n',
        route: '/project',
        layout: '../layouts/Project',
        title: 'chip-gr8 | Project',
        place: 'project',
        timeline: [
            {
                title: 'Early May',
                content: 'Started brainstorming ideas for the course project.',
            },
            {
                title: 'Mid May',
                content: 'Idea to develop a CHIP-8 emulator with AI teaching capabilities solidified; documentation is started. Project is named "Chip-Gr8" (pronounced Chip-Great).',
            },
            {
                title: 'Late May',
                content: 'Design documentation is filled out via team discussions. Prototyping work begins.',
            },
            {
                title: 'Early June',
                content: 'Python wrapper and C-based emulator programming begins. Work is focused on the C-based emulator and the CTypes integration.',
            },
            {
                title: 'Mid June',
                content: 'Visualization is completed; CHIP-8 ROMs can be visualized with no input. Emulator bugs are fixed en masse to ensure it runs in Windows, Mac, and Linux.',
            },
            {
                title: 'Late June',
                content: 'C-based emulator is completed, therefore project milestone 1 is completed. Python integration is completed, therefore project milestone 2 is completed. Support for keyboard input is operational, therefore project milestone 3 is completed ahead of schedule. Memory visualization milestone is started. Final bugs are squashed from previous milestones.',
            },
            {
                title: 'Early July',
                content: 'Development on AI tools has begun; these will be used when developing example AIs. AIs Memory visualization is working minimally, progress still being made and bugs being fixed.',
            },
            {
                title: 'Mid July',
                content: 'Memory visualization module is completed, therefore concluding milestone 4. AI tools have been completed, therefore completing milestone 5. Development on example AIs begins.',
            },
            {
                title: 'Late July',
                content: 'Example AIs are worked on to provide demonstration-worthy agents. UI upgrades are implemented. Final bugs are wrapped up if time permits.',
            },
        ],
    }),

};
