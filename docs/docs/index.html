<!DOCTYPE html><html><head><title class="next-head">chip-gr8 | Docs</title><meta charSet="UTF-8" class="next-head"/><meta name="description" content="" class="next-head"/><meta name="keywords" content="" class="next-head"/><meta name="author" content="Eric Buss" class="next-head"/><meta name="viewport" content="width=device-width, initial-scale=1.0" class="next-head"/><link rel="shortcut icon" href="/chip-gr8/static/favicon.ico" class="next-head"/><link rel="stylesheet" href="/chip-gr8/static/css/github.css" class="next-head"/><link rel="stylesheet" href="/chip-gr8/static/css/spectre.min.css" class="next-head"/><link rel="stylesheet" href="/chip-gr8/static/css/spectre-exp.min.css" class="next-head"/><link rel="stylesheet" href="/chip-gr8/static/css/font-awesome.min.css" class="next-head"/><link rel="stylesheet" href="/chip-gr8/static/css/animate.css" class="next-head"/><script src="/chip-gr8/static/js/es5-shim.min.js" class="next-head"></script><script src="/chip-gr8/static/js/es6-shim.min.js" class="next-head"></script><script src="/chip-gr8/static/js/object-shim.js" class="next-head"></script><link rel="preload" href="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/docs.js" as="script"/><link rel="preload" href="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/_app.js" as="script"/><link rel="preload" href="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/_error.js" as="script"/><link rel="preload" href="/chip-gr8/_next/static/runtime/webpack-f4542de9ce6104e90191.js" as="script"/><link rel="preload" href="/chip-gr8/_next/static/chunks/commons.b65b66a62ec853539132.js" as="script"/><link rel="preload" href="/chip-gr8/_next/static/runtime/main-5eeb1329856f13944236.js" as="script"/><link rel="stylesheet" href="/chip-gr8/_next/static/css/commons.f5d41e86.chunk.css"/></head><body><div id="__next"><div id="page"><header class="navbar"><div class="scroll-marker" style="width:NaN%"></div><section class="navbar-section container grid-md"><div class="left"><a class="m-md home " href="/chip-gr8/index/"><i class="fas fa-home"></i>Home</a><a class="m-md " href="/chip-gr8/about/"><i class="fas fa-info"></i>About</a><a class="m-md active" href="/chip-gr8/docs/"><i class="fas fa-book"></i>Docs</a></div><div class="fill-width"><div class="float-right hide-xs text-sm center"><input type="text" placeholder="Type to search..." value="" class="closed"/><a class="p-md subtle-accent"><i class="fas fa-search fa-lg"></i></a><a target="_blank" href="https://github.com/awiggs/chip-gr8" class="p-md subtle-accent"><i class="fab fa-github fa-lg"></i></a></div><div class="search hide-xs text-sm "></div></div></section></header><div class="side-nav text-center hide-xl"><ul class="nav outer d-inline-block text-left"></ul></div><div class="search-results"><div class="container grid-md"></div></div><div class="content container grid-md"><div class="md indexable"><a class="anchor-point" id="overview"></a><a class="anchor" href="#overview"><h1>Overview</h1><br/></a><p>Chip-Gr8 is distributed through <a href="https://pypi.org/project/pip/">pip</a>! To install run</p><div class="editor"><div class="code" data-lang=""><div class="text"><pre>pip install chipgr8</pre></div></div></div><p>Currently Chip-Gr8 only supports python 3.6 and 3.7. We provide binaries for Chip-Gr8&#x27;s backend for Windows users with the following configurations: Python36 (32 and 64 bit) and Python37 (32 and 64 bit). For Mac and Linux users <code>pip install</code> should build the backend binaries using your system&#x27;s compiler.</p><p>For additional documentation see the <a href="../static/Chip-Gr8-Reference-Manual.pdf">Chip-Gr8 Reference Manual</a>.</p><a class="anchor-point" id="writingyourfirstagent"></a><a class="anchor" href="#writingyourfirstagent"><h1>Writing Your First Agent</h1><br/></a><p>This example will help you write your first AI agent. An AI agent performs two key tasks, observations and actions. To get started import the Chip-Gr8 API, and a game object. The game objects provide useful defaults for observations, actions, as well as the correct ROM name. For this example we will use the game Squash. Squash is a single player Pong. We will also import random for later.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span></div><div class="text"><pre><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> chipgr8
<span class="hljs-keyword">from</span> chipgr8.games <span class="hljs-keyword">import</span> Squash</pre></div></div></div><p>AI agents are trained and run in loops. This is typically done with a while loop where you wait for a CHIP-8 VM instance to be done. For our first agent let&#x27;s just pick a random action. In order to run this agent we will need to create a VM instance to run it on and load the Squash ROM.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>vm = chipgr8.init(ROM=Squash.ROM)</pre></div></div></div><p>By default the API returns a VM appropriate for running a single AI. We will now create a loop where we repeatedly choose a random action. <code>Squash.actions</code> provides a list of all the valid Squash game actions. We also need to indicate when the VM instance should be considered done. The Squash object also provides this in its set of observations, so we will observe the VM and check to see if the VM is done.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span></div><div class="text"><pre><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vm.done():
    vm.act(random.choice(Squash.actions))
    observations = Squash.observe(vm)
    vm.doneIf(observations.done)</pre></div></div></div><p>Our AI will now run, but we will not be able to see it perform any of its actions. We can watch a replay using the <code>.inputHistory</code> of our VM. The <code>.go()</code> method will loop the VM instance for us.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>vms = chipgr8.init(ROM=Squash.ROM, instances=<span class="hljs-number">100</span>)</pre></div></div></div><p>We can now iterate over the vms and run each one like we did before.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span></div><div class="text"><pre>chipgr8.init(
    ROM=Squash.ROM,
    inputHistory=vm.inputHistory,
    display=<span class="hljs-literal">True</span>
).go()</pre></div></div></div><p>Our AI is not very good, but we can easily make it better just by running multiple random AI agents and picking the best one. Letâ€™s start by creating 100 VM instances.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span></div><div class="text"><pre><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> vms.done():
    <span class="hljs-keyword">for</span> vm <span class="hljs-keyword">in</span> vms:
        vm.act(random.choice(Squash.actions))
        observations = Squash.observe(vm)
        vm.doneIf(observations.done)</pre></div></div></div><p>This approach is a little slow though since we have to run every VM instance as part of the same process. We can take advantage of a machine&#x27;s multiple cores by using the VMs <code>.inParallel()</code> method. This method requires us to refactor our code a little bit. This method expects a function which will be called repeatedly until the vm instance is done. We can do this by taking our inner section of the loop and turning it into a function.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span></div><div class="text"><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span><span class="hljs-params">(vm)</span>:</span>
    vm.act(random.choice(Squash.actions))
    observations = Squash.observe(vm)
    vm.doneIf(observations.done)

vms.inParallel(action)</pre></div></div></div><p>We can now just pick the best vm of the bunch. The Squash object thankfully has another observation that can help us: score. We can use the VMs <code>.maxBy()</code> function to get the best VM.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>best = vms.maxBy(<span class="hljs-keyword">lambda</span> vm : Squash.observe(vm).score)</pre></div></div></div><p>We can now watch this VM like we did before using its <code>inputHistory</code>. Congratulations on writing your first Chip-Gr8 AI agent! You can find the final code altogether below.</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span><span class="line-number">21</span><span class="line-number">22</span><span class="line-number">23</span></div><div class="text"><pre><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> chipgr8
<span class="hljs-keyword">from</span> chipgr8.games <span class="hljs-keyword">import</span> Squash

<span class="hljs-comment"># This action is performed repeatedly until the VM is done</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span><span class="hljs-params">(vm)</span>:</span>
    vm.act(random.choice(Squash.actions))
    observations = Squash.observe(vm)
    vm.doneIf(observations.done)

<span class="hljs-comment"># Create 100 CHIP-8 VM instances</span>
vms = chipgr8.init(ROM=Squash.ROM, instances=<span class="hljs-number">100</span>)
<span class="hljs-comment"># Run all our random agents</span>
vms.inParallel(action)
<span class="hljs-comment"># Pick the best one</span>
best = vms.maxBy(<span class="hljs-keyword">lambda</span> vm : Squash.observe(vm).score)

<span class="hljs-comment"># Show a replay of the best</span>
chipgr8.init(
    ROM=Squash.ROM,
    inputHistory=best.inputHistory,
    display=<span class="hljs-literal">True</span>
).go()</pre></div></div></div><a class="anchor-point" id="queryingmemory"></a><a class="anchor" href="#queryingmemory"><h1>Querying Memory</h1><br/></a><p>In order to support more games, or find additional values from CHIP-8 RAM for games already included with Chip-Gr8, components are provided for querying memory. These components are meant to be used in a workflow like the following:</p><ol><li>Start the Chip-Gr8 display with the ROM you want to query.</li><li>Put the VM into a state you understand.</li><li>Create a <code>Query</code> object and use a predicate to limit the number of matching memory addresses.</li><li>Change the VM to a new state and use a new predicate to further filter the results.</li><li>Repeat step 4 until there is only a single address that matches.</li><li>Copy the <code>Query</code> out to a file.</li></ol><p>Several steps are made easier by the fact that <code>Query</code> and <code>Observer</code> objects will print their own source code in the REPL. You can easily write these to a file using the write function.</p><a class="anchor-point" id="queries"></a><a class="anchor" href="#queries"><h2>Queries</h2><br/></a><p>Queries provide several predicates to limit matched memory addresses, like <code>.eq()</code>, <code>.dec()</code>, <code>.lte()</code>, etc. A list of all memory addresses, along with their previously queried values can be found using the <code>.previous</code> field. For example:</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span></div><div class="text"><pre>q = Query(vm)
q.eq(<span class="hljs-number">0x04</span>)
print(q.previous)</pre></div></div></div><p>You can instantiate a finished <code>Query</code> by providing an address instead of a VM instance. For example, to create a query that looks at address 0x200:</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>q = Query(<span class="hljs-number">0x200</span>)</pre></div></div></div><p>This <code>Query</code> can now be used to retrieve the value in CHIP-8 RAM at 0x200 of any VM instance with:</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>q.observe(vm)</pre></div></div></div><a class="anchor-point" id="observers"></a><a class="anchor" href="#observers"><h2>Observers</h2><br/></a><p>Queries can be combined using an <code>Observer</code>. An <code>Observer</code> is just a collection of queries and functions that provides one method, observe, which applies all these queries and functions to a provided VM instance and returns the result as a <code>NamedList</code>. A <code>NamedList</code> is a data structure that behaves like a Python list, but can be accessed by attributes and keys. For example, to create a list of one element, y, with a key, <code>key</code></p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span></div><div class="text"><pre>myNamedList = NamedList([<span class="hljs-string">'key'</span>], [<span class="hljs-number">7</span>])

<span class="hljs-comment"># To access the element you can use the following ways:</span>
myNameList[<span class="hljs-number">0</span>]     <span class="hljs-comment"># By index</span>
myNameList.key    <span class="hljs-comment"># By attribute</span>
myNameList[<span class="hljs-string">'key'</span>] <span class="hljs-comment"># By key</span></pre></div></div></div><p>To add queries to an <code>Observer</code> you can call <code>.addQuery()</code>. This method also accepts as the query a function that takes two arguments. The first argument is a collection of all non-function observations. The second is the VM instance. This allows you to create combinational queries. For example</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span></div><div class="text"><pre>o = Observer()
o.addQuery(<span class="hljs-string">'lives'</span>, Query(<span class="hljs-number">0x115</span>))
o.addQuery(<span class="hljs-string">'done'</span>,  <span class="hljs-keyword">lambda</span> o, vm : o.lives == <span class="hljs-number">0</span>)</pre></div></div></div><a class="anchor-point" id="games"></a><a class="anchor" href="#games"><h2>Games</h2><br/></a><p>Games provide actions, observations, and a ROM all in one package. Several games are provided out of the box, but you can also create your own game objects for ROMs not included with Chip-Gr8.</p><a class="anchor-point" id="apireference"></a><a class="anchor" href="#apireference"><h1>API Reference</h1><br/></a><a class="anchor-point" id="constants"></a><a class="anchor" href="#constants"><h2>Constants</h2><br/></a><h3 id="defaultbindings"><code>defaultBindings</code></h3><p>Default key bindings for the Chip-Gr8 display as a Python dictionary.</p><h3 id="themes"><code>themes</code></h3><p>A Python dictionary of the builtin Chip-Gr8 themes.</p><a class="anchor-point" id="functions"></a><a class="anchor" href="#functions"><h2>Functions</h2><br/></a><h3 id="assemble(source=none,inpath=none,outpath=none)"><code>assemble(source=None, inPath=None, outPath=None)</code></h3><p>Converts assembly <code>source</code> code, or source code contained in <code>inPath</code> into binary data (a ROM). This ROM may optionally be written to file with the <code>outPath</code> argument.</p><h3 id="disassemble((parameters))"><code>disassemble((Parameters))</code></h3><p>Converts a binary ROM into an assembly source file. Returns the source. Provides option for disassembling with labels and special format.</p><h5 id="parameters">Parameters</h5><h5 id="buffer=none"><code>buffer=None</code></h5><p>The binary ROM to disassemble as a set of bytes. Optional if <code>inPath</code> is provided.</p><h5 id="inpath=none"><code>inPath=None</code></h5><p>The path to a binary ROM to disassemble. Optional if <code>buffer</code> is provided.</p><h5 id="outpath=none"><code>outPath=None</code></h5><p>If the path is provided, the source code is written to that file.</p><h5 id="labels={}"><code>labels={}</code></h5><p>A dictionary used to generate labels. If None is passed, labels will not be generated in the source.</p><h5 id="decargs=true"><code>decargs=True</code></h5><p>If True, instruction numerical operands will be output in decimal rather than hexadecimal.</p><h5 id="srcformat=&#x27;{label}{labelsep}{prefix}{instruction}\n&#x27;"><code>srcFormat=&#x27;{label}{labelSep}{prefix}{instruction}\n&#x27;</code></h5><p>A format string for lines of source code. Can contain the following variables <code>label</code>, <code>labelSep</code>, <code>prefix</code>, <code>instruction</code>, <code>addr</code>, and <code>dump</code>. For example for hexdump with address use:</p><div class="editor"><div class="code" data-lang="python"><div class="gutter"><span class="line-number">1</span></div><div class="text"><pre>srcFormat=<span class="hljs-string">'{addr} {dump}'</span></pre></div></div></div><h5 id="labelsep=&#x27;\n&#x27;"><code>labelSep = &#x27;\n  &#x27;</code></h5><p>The string used to separate labels from instructions.</p><h5 id="prefix=&#x27;&#x27;"><code>prefix=&#x27; &#x27;</code></h5><p>The string used to prefix all instructions.</p><h5 id="addrtable={}"><code>addrTable={}</code></h5><p>A table that will have addresses as keys and instructions as values.</p><h5 id="findrom(rom)"><code>findROM(rom)</code></h5><p>Returns the path to <code>rom</code> if it is one of the included ROMs.</p><h5 id="hexdump(buffer=none,inpath=none,outpath=none)"><code>hexdump(buffer=None, inPath=None, outPath=None)</code></h5><p>Dumps a <code>buffer</code> or file at <code>inPath</code> as a set of 16-bit hexadecimal values on each line (the number of bits that correspond to a CHIP-8 instruction). Writes the data to <code>outPath</code> if provided.</p><h3 id="init((parameters))"><code>init((Parameters))</code></h3><p>Returns an instance of <code>Chip8VM</code> or <code>Chip8VMs</code>. Used to configure the virtual machines for a user or a given AI agent.</p><h4 id="parameters">Parameters</h4><h5 id="rom=none"><code>ROM=None</code></h5><p>If provided will load a ROM into the VM instance or instances.</p><h5 id="frequency=600"><code>frequency=600</code></h5><p>The starting <code>frequency</code> of the VM instance or instances. Will automatically be set to the closest multiple of 60 less than or equal to the provided <code>frequency</code>.</p><h5 id="loadstate=none"><code>loadState=None</code></h5><p>A path or tag to a VM save state that will be loaded into each VM instance or instances.</p><h5 id="inputhistory=none"><code>inputHistory=None</code></h5><p>If provided user and AI input will be ignored and the history will be used to reproduce the same events.</p><h5 id="samplerate=1"><code>sampleRate=1</code></h5><p>The number of steps that are performed when an AI calls <code>act</code>.</p><h5 id="instances=1"><code>instances=1</code></h5><p>The number of VM instances to create.</p><h5 id="display=false"><code>display=False</code></h5><p>If True, the VM will create a Chip-Gr8 display. Cannot be True if instances does not equal 1.</p><h5 id="smooth=false"><code>smooth=False</code></h5><p>If True, enables the experimental smooth rendering mode. This mode is slow on most machines.</p><h5 id="startpaused=false"><code>startPaused=False</code></h5><p>If True, the VM instance will start paused.</p><h5 id="aiinputmask=0xffff"><code>aiInputMask=0xFFFF</code></h5><p>The keys usable to the AI agent as a bitmask. The keys available to the user are the bitwise inverse of this mask.</p><h5 id="foreground=(255,255,255)"><code>foreground=(255, 255, 255)</code></h5><p>The foreground color of the Chip-Gr8 display as an RGB tuple or hex code.</p><h5 id="background=(0,0,0)"><code>background=(0, 0, 0)</code></h5><p>The background color of the Chip-Gr8 display as an RGB tuple or hex code.</p><h5 id="theme=none"><code>theme=None</code></h5><p>The foreground/background color provided as a tuple.</p><h5 id="autoscroll=true"><code>autoScroll=True</code></h5><p>If True, this disassembly source will automatically scroll when the Chip-Gr8 display is open and a ROM is running.</p><h5 id="speed"><code>speed</code></h5><p>The speed at which the UI is tied to the CHIP-8 frequency. When speed is 1, games will appear to run at the provided frequency, but when speed is 2, games will appear to run twice as fast. Must be provided as an integer.</p><h3 id="readableinputhistory(inputhistory,names)"><code>readableInputHistory(inputHistory, names)</code></h3><p>Given an <code>inputHistory</code> and a set of actions, <code>names</code>, as a <code>NamedList</code>, produces a human readable version of the <code>inputHistory</code>.</p><a class="anchor-point" id="chip8vm(class)"></a><a class="anchor" href="#chip8vm(class)"><h2>Chip8VM (Class)</h2><br/></a><p>Represents a CHIP-8 virtual machine. Provides interface and controls for display and input. Rather than initializing directly, an instance of this class or its sister class <code>Chip8VMs</code> should always be instantiated using <code>init</code>.</p><h4 id=".aiinputmask"><code>.aiInputMask</code></h4><p>A number that controls what keys are usable by AI agents calling <code>act</code> and what keys are usable by a user on their keyboard. For example, an <code>aiInputMask</code> of 0x0000 will prevent an AI agent from using any keys, but a user will be able to use all keys.</p><h4 id=".inputhistory"><code>.inputHistory</code></h4><p>A list of number pairs that represent changes in key presses. The first value in the pair is the key value, the second is the clock value when input changed to that value.</p><h4 id=".paused"><code>.paused</code></h4><p>A control flag set to True if the display is paused.</p><h4 id=".pyclock"><code>.pyclock</code></h4><p>The pygame clock used to keep track of time between steps when using the Chip-Gr8 display.</p><h4 id=".record"><code>.record</code></h4><p>A control flag set to True if <code>inputHistory</code> is being recorded.</p><h4 id=".rom"><code>.ROM</code></h4><p>The path to the currently loaded game ROM.</p><h4 id=".samplerate"><code>.sampleRate</code></h4><p>The number of steps that are performed when an AI calls <code>act</code>.</p><h4 id=".smooth"><code>.smooth</code></h4><p>A control flag for the experimental smooth rendering mode. This mode is slow on most machines.</p><h4 id=".vm"><code>.VM</code></h4><p>A direct reference to the CHIP-8 C-struct. This provides direct memory access (eg. <code>VM.RAM[0x200]</code>) as well as register reference (eg. <code>VM.PC</code>). Use these fields with caution as inappropriate usage can result in a segmentation fault. Direct references to <code>VM</code> should not be maintained (no aliasing).</p><h4 id=".addbreakpoint(addr)"><code>.addBreakpoint(addr)</code></h4><p>Add a breakpoint at <code>addr</code>. When the VM steps to this address (when PC is equal to <code>addr</code>) the Chip-Gr8 display will automatically pause.</p><h4 id=".removebreakpoint(addr)"><code>.removeBreakpoint(addr)</code></h4><p>Remove a breakpoint at <code>addr</code>.</p><h4 id=".togglebreakpoint(addr)"><code>.toggleBreakpoint(addr)</code></h4><p>Toggles a breakpoint at <code>addr</code>.</p><h4 id=".clearbreakpoints()"><code>.clearBreakpoints()</code></h4><p>Clear all current breakpoints.</p><h4 id=".act(action)"><code>.act(action)</code></h4><p>Allows an AI agent to perform <code>action</code> (action is an input key value) and steps the CHIP-8 emulator forward <code>sampleRate</code> clock cycles.</p><h4 id=".ctx()"><code>.ctx()</code></h4><p>Returns an instance of the CHIP-8â€™s VRAM in a NumPy compliant format (Lazyarray). Pixel values can be addressed directly. (eg. a pixel at position (16, 8) can be retrieved with <code>ctx()[16, 8]</code>). This method is safe to call repeatedly.</p><h4 id=".done()"><code>.done()</code></h4><p>Returns True if the VM is done and has NOT been reset.</p><h4 id=".doneif(done)"><code>.doneIf(done)</code></h4><p>Signals to the VM that it is done.</p><h4 id=".go()"><code>.go()</code></h4><p>Starts the VM in an until <code>done()</code> loop, calling <code>act(0)</code> repeatedly. This is ideal for user interaction without an AI agent.</p><h4 id=".input(keys)"><code>.input(keys)</code></h4><p>Send an input key value to the CHIP-8 emulator. Input keys are masked by <code>aiInputMask</code>.</p><h4 id=".loadrom(nameorpath,reset=true)"><code>.loadROM(nameOrPath, reset=True)</code></h4><p>Loads a ROM from the provided path or searches for the name in the set of provided ROM files. If <code>reset</code> is True then VM will be reset prior to loading the ROM.</p><h4 id=".loadstate(path=none,tag=none)"><code>.loadState(path=None, tag=None)</code></h4><p>Load a CHIP-8 emulator state from a <code>path</code> or by associated <code>tag</code>, restoring a previous state of <code>VM</code>.</p><h4 id=".savestate(path=none,tag=none)"><code>.saveState(path=None, tag=None)</code></h4><p>Save the current CHIP-8 emulator state to a <code>path</code> or <code>tag</code>.</p><h4 id=".reset()"><code>.reset()</code></h4><p>Reset the VM with the current ROM still loaded.</p><h4 id=".step()"><code>.step()</code></h4><p>Step the VM forward 1 clock cycle.</p><a class="anchor-point" id="chip8vms(class)"></a><a class="anchor" href="#chip8vms(class)"><h2>Chip8VMs (Class)</h2><br/></a><p>Represents a collection of CHIP-8 virtual machines. Provides an interface for dealing with and filtering several virtual machines at the same time. This class is iterable, and will iterate over all vms that are NOT <code>done()</code>.</p><h4 id=".done()"><code>.done()</code></h4><p>Returns True if all VM instances are done.</p><h4 id=".find(predicate)"><code>.find(predicate)</code></h4><p>Find a specific VM using a function <code>predicate</code> that takes a VM as an argument and returns True or False. Returns the first VM for which the <code>predicate</code> was True. Searches done and not done VMs.</p><h4 id=".inparallel(do)"><code>.inParallel(do)</code></h4><p>Performs a function <code>do</code> on all not done VMs in parallel. The function is expected to take the VM as an argument. When using this method external vm references can become out of date due to pickling across processes.</p><h4 id=".maxby(projection)"><code>.maxBy(projection)</code></h4><p>Returns the VM with the maximum value by the given <code>projection</code>, a function that takes a VM as its argument and returns a comparable value.</p><h4 id=".minby(projection)"><code>.minBy(projection)</code></h4><p>Returns the VM with the minimum value by the given <code>projection</code>, a function that takes a VM as its argument and returns a comparable value.</p><h4 id=".reset()"><code>.reset()</code></h4><p>Resets all the VMs.</p><a class="anchor-point" id="game(class)"></a><a class="anchor" href="#game(class)"><h2>Game (Class)</h2><br/></a><p>A generic class for game specific data. Game specific instances of this class exist for each included ROM (Cave, Pong, Worm, etc.).</p><h4 id=".actions"><code>.actions</code></h4><p>A list of valid actions (key values) for the given game.</p><h4 id=".rom"><code>.ROM</code></h4><p>The name of the ROM file for this game.</p><h4 id=".observe(vm)"><code>.observe(vm)</code></h4><p>Returns a set of game specific observations given a VM.</p><a class="anchor-point" id="namedlist(class)"></a><a class="anchor" href="#namedlist(class)"><h2>NamedList (Class)</h2><br/></a><p>A list-like structure that allows elements to be accessed by named properties. Behaves like a Python list, can be iterated, indexed, spliced, and measured with <code>len()</code>.</p><h4 id=".names"><code>.names</code></h4><p>A list of keys for the list in order.</p><h4 id=".values"><code>.values</code></h4><p>A list of values for the list in order.</p><h4 id=".append(name,value)"><code>.append(name, value)</code></h4><p>Append a <code>name</code> and <code>value</code> to the list.</p><h4 id=".nparray()"><code>.nparray()</code></h4><p>Retrieve the values of the list as a NumPy ndarray.</p><h4 id=".tensor()"><code>.tensor()</code></h4><p>Retrieve the values of the list as a TensorFlow tensor.</p><a class="anchor-point" id="observer(class)"></a><a class="anchor" href="#observer(class)"><h2>Observer (Class)</h2><br/></a><p>Represents a collection of queries that can be applied to a VM acquiring a set of observations.</p><h4 id=".addquery(name,query)"><code>.addQuery(name, query)</code></h4><p>Add a query with an associated name to an observer. Accepts either a finalized query or a function that accepts a set of observations <code>(NamedList)</code> as the first argument and a vm instance as its second argument. This function argument can be used to create compound queries.</p><h4 id=".observe(vm)"><code>.observe(vm)</code></h4><p>Retrieve a set of observations as a <code>NamedList</code> given a <code>vm</code> instance.</p><a class="anchor-point" id="query(class)"></a><a class="anchor" href="#query(class)"><h2>Query (Class)</h2><br/></a><p>Used to find a specific memory address. When using a query to search for a memory address, several predicates can be used to filter the query.</p><h4 id=".done"><code>.done</code></h4><p>True if the query has found 0 or 1 addresses.</p><h4 id=".success"><code>.success</code></h4><p>True if the query has found 1 address.</p><h4 id=".dec()"><code>.dec()</code></h4><p>Filter queried memory addresses by values that have decreased since the last query.</p><h4 id=".eq(value)"><code>.eq(value)</code></h4><p>Filter queried memory addresses by values that equal <code>value</code>.</p><h4 id=".gt(value)"><code>.gt(value)</code></h4><p>Filter queried memory addresses by values that are greater than <code>value</code>.</p><h4 id=".gte(value)"><code>.gte(value)</code></h4><p>Filter queried memory addresses by values that are greater than or equal to <code>value</code>.</p><h4 id=".inc()"><code>.inc()</code></h4><p>Filter queried memory addresses by values that have increased since the last query.</p><h4 id=".lt(value)"><code>.lt(value)</code></h4><p>Filter queried memory addresses by values that are less than <code>value</code>.</p><h4 id=".lte(value)"><code>.lte(value)</code></h4><p>Filter queried memory addresses by values that are less than or equal to <code>value</code>.</p><h4 id=".observe(vm)"><code>.observe(vm)</code></h4><p>If a query is finished this method returns the value at the VM instance&#x27;s RAM corresponding to this query, otherwise it raises an Excception.</p><h4 id=".unknown()"><code>.unknown()</code></h4><p>Refresh the previous values of all currently queried memory addresses.</p></div></div></div><footer><div class="container grid-md"><div class="columns"><div class="column col-3 hide-sm"><a target="_blank" href="https://github.com/awiggs/chip-gr8" class="p-md subtle"><i class="fab fa-github fa-lg"></i></a></div><div class="column col-6 col-sm-12"><p class="text-center subtext">Built with <i class="fas fa-heart clr-accent"></i> using <a target="_blank" href="https://nextjs.org/" class="subtle">Nextjs</a>, <a target="_blank" href="https://picturepan2.github.io/spectre/index.html" class="subtle">Spectre.css</a>, &amp; <a target="_blank" href="/blog/siteHistory" class="subtle">More</a></p></div><div class="column col-3 hide-sm"><p class="text-right subtext">Â© Chip-Gr8 Team 2019</p></div></div></div></footer></div><script>__NEXT_DATA__ = {"props":{"pageProps":{}},"page":"/docs","query":{},"buildId":"cCVcrCOohM8h9GVqXePqX","assetPrefix":"/chip-gr8","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/docs" src="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/docs.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/chip-gr8/_next/static/cCVcrCOohM8h9GVqXePqX/pages/_error.js"></script><script src="/chip-gr8/_next/static/runtime/webpack-f4542de9ce6104e90191.js" async=""></script><script src="/chip-gr8/_next/static/chunks/commons.b65b66a62ec853539132.js" async=""></script><script src="/chip-gr8/_next/static/runtime/main-5eeb1329856f13944236.js" async=""></script></body></html>